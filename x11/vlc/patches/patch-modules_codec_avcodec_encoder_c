https://code.videolan.org/videolan/vlc/-/merge_requests/6657
https://code.videolan.org/videolan/vlc/-/merge_requests/3854

Index: modules/codec/avcodec/encoder.c
--- modules/codec/avcodec/encoder.c.orig
+++ modules/codec/avcodec/encoder.c
@@ -181,6 +181,7 @@ static const uint64_t pi_channels_map[][2] =
     { AV_CH_STEREO_RIGHT,      0 },
 };
 
+#if (LIBAVCODEC_VERSION_INT < AV_VERSION_INT( 59, 24, 100 ))
 static const uint32_t channel_mask[][2] = {
     {0,0},
     {AOUT_CHAN_CENTER, AV_CH_LAYOUT_MONO},
@@ -193,6 +194,7 @@ static const uint32_t channel_mask[][2] = {
     {AOUT_CHANS_7_1, AV_CH_LAYOUT_7POINT1},
     {AOUT_CHANS_8_1, AV_CH_LAYOUT_OCTAGONAL},
 };
+#endif
 
 static const char *const ppsz_enc_options[] = {
     "keyint", "bframes", "vt", "qmin", "qmax", "codec", "hq",
@@ -252,19 +254,29 @@ static void probe_video_frame_rate( encoder_t *p_enc, 
                                   ( p_enc->fmt_out.i_codec == VLC_CODEC_MP4V ? 25 : CLOCK_FREQ );
 
     msg_Dbg( p_enc, "Time base for probing set to %d/%d", p_context->time_base.num, p_context->time_base.den );
-    if( p_codec->supported_framerates )
+
+    const AVRational *supported_framerates;
+#if (LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 61, 13, 100 ))
+    if (avcodec_get_supported_config(p_context, p_codec, AV_CODEC_CONFIG_FRAME_RATE, 0,
+                                     (const void **)&supported_framerates, NULL) < 0)
+        supported_framerates = NULL;
+#else
+    supported_framerates = p_codec->supported_framerates;
+#endif
+
+    if( supported_framerates )
     {
         /* We are finding fps values so 1/time_base */
         AVRational target = {
             .num = p_context->time_base.den,
             .den = p_context->time_base.num
         };
-        int idx = av_find_nearest_q_idx(target, p_codec->supported_framerates);
+        int idx = av_find_nearest_q_idx(target, supported_framerates);
 
-        p_context->time_base.num = p_codec->supported_framerates[idx].den ?
-                                    p_codec->supported_framerates[idx].den : 1;
-        p_context->time_base.den = p_codec->supported_framerates[idx].den ?
-                                    p_codec->supported_framerates[idx].num : CLOCK_FREQ;
+        p_context->time_base.num = supported_framerates[idx].den ?
+                                    supported_framerates[idx].den : 1;
+        p_context->time_base.den = supported_framerates[idx].den ?
+                                    supported_framerates[idx].num : CLOCK_FREQ;
 
         /* If we have something reasonable on supported framerates, use that*/
         if( p_context->time_base.den && p_context->time_base.den < CLOCK_FREQ )
@@ -468,30 +480,30 @@ int InitVideoEnc( vlc_object_t *p_this )
     psz_val = var_GetString( p_enc, ENC_CFG_PREFIX "aac-profile" );
     /* libavcodec uses faac encoder atm, and it has issues with
      * other than low-complexity profile, so default to that */
-    p_sys->i_aac_profile = FF_PROFILE_AAC_LOW;
+    p_sys->i_aac_profile = AV_PROFILE_AAC_LOW;
     if( psz_val && *psz_val )
     {
         if( !strncmp( psz_val, "main", 4 ) )
-            p_sys->i_aac_profile = FF_PROFILE_AAC_MAIN;
+            p_sys->i_aac_profile = AV_PROFILE_AAC_MAIN;
         else if( !strncmp( psz_val, "low", 3 ) )
-            p_sys->i_aac_profile = FF_PROFILE_AAC_LOW;
+            p_sys->i_aac_profile = AV_PROFILE_AAC_LOW;
         else if( !strncmp( psz_val, "ssr", 3 ) )
-            p_sys->i_aac_profile = FF_PROFILE_AAC_SSR;
+            p_sys->i_aac_profile = AV_PROFILE_AAC_SSR;
         else if( !strncmp( psz_val, "ltp", 3 ) )
-            p_sys->i_aac_profile = FF_PROFILE_AAC_LTP;
+            p_sys->i_aac_profile = AV_PROFILE_AAC_LTP;
 /* These require libavcodec with libfdk-aac */
         else if( !strncmp( psz_val, "hev2", 4 ) )
-            p_sys->i_aac_profile = FF_PROFILE_AAC_HE_V2;
+            p_sys->i_aac_profile = AV_PROFILE_AAC_HE_V2;
         else if( !strncmp( psz_val, "hev1", 4 ) )
-            p_sys->i_aac_profile = FF_PROFILE_AAC_HE;
+            p_sys->i_aac_profile = AV_PROFILE_AAC_HE;
         else if( !strncmp( psz_val, "ld", 2 ) )
-            p_sys->i_aac_profile = FF_PROFILE_AAC_LD;
+            p_sys->i_aac_profile = AV_PROFILE_AAC_LD;
         else if( !strncmp( psz_val, "eld", 3 ) )
-            p_sys->i_aac_profile = FF_PROFILE_AAC_ELD;
+            p_sys->i_aac_profile = AV_PROFILE_AAC_ELD;
         else
         {
             msg_Warn( p_enc, "unknown AAC profile requested, setting it to low" );
-            p_sys->i_aac_profile = FF_PROFILE_AAC_LOW;
+            p_sys->i_aac_profile = AV_PROFILE_AAC_LOW;
         }
     }
     free( psz_val );
@@ -553,7 +565,16 @@ int InitVideoEnc( vlc_object_t *p_this )
         p_enc->fmt_in.video.i_chroma = p_enc->fmt_in.i_codec;
         GetFfmpegChroma( &p_context->pix_fmt, &p_enc->fmt_in.video );
 
-        if( p_codec->pix_fmts )
+        const enum AVPixelFormat *pix_fmts;
+#if (LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 61, 13, 100 ))
+        if (avcodec_get_supported_config(p_context, p_codec, AV_CODEC_CONFIG_PIX_FORMAT, 0,
+                                        (const void **)&pix_fmts, NULL) < 0)
+            pix_fmts = NULL;
+#else
+        pix_fmts = p_codec->pix_fmts;
+#endif
+
+        if( pix_fmts )
         {
             static const enum AVPixelFormat vlc_pix_fmts[] = {
                 AV_PIX_FMT_YUV420P,
@@ -561,8 +582,8 @@ int InitVideoEnc( vlc_object_t *p_this )
                 AV_PIX_FMT_RGB24,
             };
             bool found = false;
-            const enum PixelFormat *p = p_codec->pix_fmts;
-            for( ; !found && *p != -1; p++ )
+            const enum AVPixelFormat *p = pix_fmts;
+            for( ; !found && *p != AV_PIX_FMT_NONE; p++ )
             {
                 for( size_t i = 0; i < ARRAY_SIZE(vlc_pix_fmts); ++i )
                 {
@@ -574,7 +595,7 @@ int InitVideoEnc( vlc_object_t *p_this )
                     }
                 }
             }
-            if (!found) p_context->pix_fmt = p_codec->pix_fmts[0];
+            if (!found) p_context->pix_fmt = pix_fmts[0];
             GetVlcChroma( &p_enc->fmt_in.video, p_context->pix_fmt );
             p_enc->fmt_in.i_codec = p_enc->fmt_in.video.i_chroma;
         }
@@ -699,22 +720,29 @@ int InitVideoEnc( vlc_object_t *p_this )
     }
     else if( p_enc->fmt_in.i_cat == AUDIO_ES )
     {
+        const enum AVSampleFormat *sample_fmts;
+#if (LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 61, 13, 100 ))
+        if (avcodec_get_supported_config(p_context, p_codec, AV_CODEC_CONFIG_SAMPLE_FORMAT, 0,
+                                        (const void **)&sample_fmts, NULL) < 0)
+            sample_fmts = NULL;
+#else
+        sample_fmts = p_codec->sample_fmts;
+#endif
+
         p_context->codec_type  = AVMEDIA_TYPE_AUDIO;
-        p_context->sample_fmt  = p_codec->sample_fmts ?
-                                    p_codec->sample_fmts[0] :
-                                    AV_SAMPLE_FMT_S16;
+        p_context->sample_fmt  = sample_fmts ? sample_fmts[0] : AV_SAMPLE_FMT_S16;
 
         /* Try to match avcodec input format to vlc format so we could avoid one
            format conversion */
         if( GetVlcAudioFormat( p_context->sample_fmt ) != p_enc->fmt_in.i_codec
-            && p_codec->sample_fmts )
+            && sample_fmts )
         {
             msg_Dbg( p_enc, "Trying to find more suitable sample format instead of %s", av_get_sample_fmt_name( p_context->sample_fmt ) );
-            for( unsigned int i=0; p_codec->sample_fmts[i] != -1; i++ )
+            for( unsigned int i=0; sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++ )
             {
-                if( GetVlcAudioFormat( p_codec->sample_fmts[i] ) == p_enc->fmt_in.i_codec )
+                if( GetVlcAudioFormat( sample_fmts[i] ) == p_enc->fmt_in.i_codec )
                 {
-                    p_context->sample_fmt = p_codec->sample_fmts[i];
+                    p_context->sample_fmt = sample_fmts[i];
                     msg_Dbg( p_enc, "Using %s as new sample format", av_get_sample_fmt_name( p_context->sample_fmt ) );
                     break;
                 }
@@ -723,14 +751,14 @@ int InitVideoEnc( vlc_object_t *p_this )
         p_sys->b_planar = av_sample_fmt_is_planar( p_context->sample_fmt );
         // Try if we can use interleaved format for codec input as VLC doesn't really do planar audio yet
         // FIXME: Remove when planar/interleaved audio in vlc is equally supported
-        if( p_sys->b_planar && p_codec->sample_fmts )
+        if( p_sys->b_planar && sample_fmts )
         {
             msg_Dbg( p_enc, "Trying to find packet sample format instead of planar %s", av_get_sample_fmt_name( p_context->sample_fmt ) );
-            for( unsigned int i=0; p_codec->sample_fmts[i] != -1; i++ )
+            for( unsigned int i=0; sample_fmts[i] != AV_SAMPLE_FMT_NONE; i++ )
             {
-                if( !av_sample_fmt_is_planar( p_codec->sample_fmts[i] ) )
+                if( !av_sample_fmt_is_planar( sample_fmts[i] ) )
                 {
-                    p_context->sample_fmt = p_codec->sample_fmts[i];
+                    p_context->sample_fmt = sample_fmts[i];
                     msg_Dbg( p_enc, "Changing to packet format %s as new sample format", av_get_sample_fmt_name( p_context->sample_fmt ) );
                     break;
                 }
@@ -745,58 +773,43 @@ int InitVideoEnc( vlc_object_t *p_this )
         date_Set( &p_sys->buffer_date, AV_NOPTS_VALUE );
         p_context->time_base.num = 1;
         p_context->time_base.den = p_context->sample_rate;
-        p_context->channels      = p_enc->fmt_out.audio.i_channels;
-#if LIBAVUTIL_VERSION_CHECK( 52, 2, 6, 0, 0)
-        p_context->channel_layout = channel_mask[p_context->channels][1];
 
-        /* Setup Channel ordering for multichannel audio
+        /* Setup Channel ordering for audio
          * as VLC channel order isn't same as libavcodec expects
          */
 
         p_sys->i_channels_to_reorder = 0;
 
-        /* Specified order
+        /* Create channel layout for avcodec
          * Copied from audio.c
          */
-        const unsigned i_order_max = 8 * sizeof(p_context->channel_layout);
         uint32_t pi_order_dst[AOUT_CHAN_MAX] = { };
         uint32_t order_mask = 0;
         int i_channels_src = 0;
 
-        if( p_context->channel_layout )
-        {
-            msg_Dbg( p_enc, "Creating channel order for reordering");
-            for( unsigned i = 0; i < sizeof(pi_channels_map)/sizeof(*pi_channels_map); i++ )
+        msg_Dbg( p_enc, "Creating channel order for reordering");
+#if (LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 59, 24, 100 ))
+        av_channel_layout_default( &p_context->ch_layout, p_enc->fmt_out.audio.i_channels );
+        uint64_t channel_mask = p_context->ch_layout.u.mask;
+#else
+        p_context->channels = p_enc->fmt_out.audio.i_channels;
+        p_context->channel_layout = channel_mask[p_context->channels][1];
+        uint64_t channel_mask = p_context->channel_layout;
+#endif
+        for( unsigned i = 0; i < sizeof(pi_channels_map)/sizeof(*pi_channels_map); i++ )
+            if( channel_mask & pi_channels_map[i][0] )
             {
-                if( p_context->channel_layout & pi_channels_map[i][0] )
-                {
-                    msg_Dbg( p_enc, "%d %"PRIx64" mapped to %"PRIx64"", i_channels_src, pi_channels_map[i][0], pi_channels_map[i][1]);
-                    pi_order_dst[i_channels_src++] = pi_channels_map[i][1];
-                    order_mask |= pi_channels_map[i][1];
-                }
+                msg_Dbg( p_enc, "%d %"PRIx64" mapped to %"PRIx64"", i_channels_src, pi_channels_map[i][0], pi_channels_map[i][1]);
+                pi_order_dst[i_channels_src++] = pi_channels_map[i][1];
+                order_mask |= pi_channels_map[i][1];
             }
-        }
-        else
-        {
-            msg_Dbg( p_enc, "Creating default channel order for reordering");
-            /* Create default order  */
-            for( unsigned int i = 0; i < __MIN( i_order_max, (unsigned)p_sys->p_context->channels ); i++ )
-            {
-                if( i < sizeof(pi_channels_map)/sizeof(*pi_channels_map) )
-                {
-                    msg_Dbg( p_enc, "%d channel is %"PRIx64"", i_channels_src, pi_channels_map[i][1]);
-                    pi_order_dst[i_channels_src++] = pi_channels_map[i][1];
-                    order_mask |= pi_channels_map[i][1];
-                }
-            }
-        }
-        if( i_channels_src != p_context->channels )
+
+        if( i_channels_src != p_enc->fmt_out.audio.i_channels )
             msg_Err( p_enc, "Channel layout not understood" );
 
         p_sys->i_channels_to_reorder =
             aout_CheckChannelReorder( NULL, pi_order_dst, order_mask,
                                       p_sys->pi_reorder_layout );
-#endif
 
         if ( p_enc->fmt_out.i_codec == VLC_CODEC_MP4A )
         {
@@ -897,7 +910,7 @@ int InitVideoEnc( vlc_object_t *p_this )
     if( ret )
     {
         if( p_enc->fmt_in.i_cat != AUDIO_ES ||
-                (p_context->channels <= 2 && i_codec_id != AV_CODEC_ID_MP2
+                (p_enc->fmt_out.audio.i_channels <= 2 && i_codec_id != AV_CODEC_ID_MP2
                  && i_codec_id != AV_CODEC_ID_MP3) )
 errmsg:
         {
@@ -922,10 +935,14 @@ errmsg:
             goto error;
         }
 
-        if( p_context->channels > 2 )
+        if( p_enc->fmt_out.audio.i_channels > 2 )
         {
+#if (LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 59, 24, 100 ))
+            av_channel_layout_default( &p_context->ch_layout, 2 );
+#else
             p_context->channels = 2;
             p_context->channel_layout = channel_mask[p_context->channels][1];
+#endif
 
             /* Change fmt_in in order to ask for a channels conversion */
             p_enc->fmt_in.audio.i_channels =
@@ -1028,7 +1045,7 @@ errmsg:
                                     p_context->frame_size :
                                     AV_INPUT_BUFFER_MIN_SIZE;
         p_sys->i_buffer_out = av_samples_get_buffer_size(NULL,
-                p_sys->p_context->channels, p_sys->i_frame_size,
+                p_enc->fmt_out.audio.i_channels, p_sys->i_frame_size,
                 p_sys->p_context->sample_fmt, DEFAULT_ALIGN);
         p_sys->p_buffer = av_malloc( p_sys->i_buffer_out );
         if ( unlikely( p_sys->p_buffer == NULL ) )
@@ -1227,8 +1244,19 @@ static block_t *EncodeVideo( encoder_t *p_enc, picture
         frame->pict_type = 0;
 
         frame->repeat_pict = p_pict->i_nb_fields - 2;
+#if (LIBAVUTIL_VERSION_INT >= AV_VERSION_INT( 58, 7, 100 ))
+        if (p_pict->b_progressive)
+            frame->flags &= ~AV_FRAME_FLAG_INTERLACED;
+        else
+            frame->flags |= AV_FRAME_FLAG_INTERLACED;
+        if (p_pict->b_top_field_first)
+            frame->flags |= AV_FRAME_FLAG_TOP_FIELD_FIRST;
+        else
+            frame->flags &= ~AV_FRAME_FLAG_TOP_FIELD_FIRST;
+#else
         frame->interlaced_frame = !p_pict->b_progressive;
         frame->top_field_first = !!p_pict->b_top_field_first;
+#endif
 
         frame->format = p_sys->p_context->pix_fmt;
         frame->width = p_sys->p_context->width;
@@ -1278,13 +1306,17 @@ static block_t *handle_delay_buffer( encoder_t *p_enc,
 {
     block_t *p_block = NULL;
     //How much we need to copy from new packet
-    const size_t leftover = leftover_samples * p_sys->p_context->channels * p_sys->i_sample_bytes;
+    const size_t leftover = leftover_samples * p_enc->fmt_out.audio.i_channels * p_sys->i_sample_bytes;
 
     av_frame_unref( p_sys->frame );
     p_sys->frame->format     = p_sys->p_context->sample_fmt;
     p_sys->frame->nb_samples = leftover_samples + p_sys->i_samples_delay;
+#if (LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 59, 24, 100 ))
+    av_channel_layout_copy(&p_sys->frame->ch_layout, &p_sys->p_context->ch_layout);
+#else
     p_sys->frame->channel_layout = p_sys->p_context->channel_layout;
     p_sys->frame->channels = p_sys->p_context->channels;
+#endif
 
     p_sys->frame->pts        = date_Get( &p_sys->buffer_date ) * p_sys->p_context->time_base.den /
                                 CLOCK_FREQ / p_sys->p_context->time_base.num;
@@ -1301,7 +1333,7 @@ static block_t *handle_delay_buffer( encoder_t *p_enc,
         // We need to deinterleave from p_aout_buf to p_buffer the leftover bytes
         if( p_sys->b_planar )
             aout_Deinterleave( p_sys->p_interleave_buf, p_sys->p_buffer,
-                p_sys->i_frame_size, p_sys->p_context->channels, p_enc->fmt_in.i_codec );
+                p_sys->i_frame_size, p_enc->fmt_out.audio.i_channels, p_enc->fmt_in.i_codec );
         else
             memcpy( p_sys->p_buffer + buffer_delay, p_aout_buf->p_buffer, leftover);
 
@@ -1319,7 +1351,7 @@ static block_t *handle_delay_buffer( encoder_t *p_enc,
         memset( p_sys->p_buffer + (leftover+buffer_delay), 0, padding_size );
         buffer_delay += padding_size;
     }
-    if( avcodec_fill_audio_frame( p_sys->frame, p_sys->p_context->channels,
+    if( avcodec_fill_audio_frame( p_sys->frame, p_enc->fmt_out.audio.i_channels,
             p_sys->p_context->sample_fmt, p_sys->b_planar ? p_sys->p_interleave_buf : p_sys->p_buffer,
             p_sys->i_buffer_out,
             DEFAULT_ALIGN) < 0 )
@@ -1349,7 +1381,7 @@ static block_t *EncodeAudio( encoder_t *p_enc, block_t
 
     //i_bytes_left is amount of bytes we get
     i_samples_left = p_aout_buf ? p_aout_buf->i_nb_samples : 0;
-    buffer_delay = p_sys->i_samples_delay * p_sys->i_sample_bytes * p_sys->p_context->channels;
+    buffer_delay = p_sys->i_samples_delay * p_sys->i_sample_bytes * p_enc->fmt_out.audio.i_channels;
 
     //p_sys->i_buffer_out = p_sys->i_frame_size * chan * p_sys->i_sample_bytes
     //Calculate how many bytes we would need from current buffer to fill frame
@@ -1414,16 +1446,20 @@ static block_t *EncodeAudio( encoder_t *p_enc, block_t
         p_sys->frame->pts        = date_Get( &p_sys->buffer_date ) * p_sys->p_context->time_base.den /
                                     CLOCK_FREQ / p_sys->p_context->time_base.num;
 
+#if (LIBAVCODEC_VERSION_INT >= AV_VERSION_INT( 59, 24, 100 ))
+        av_channel_layout_copy(&p_sys->frame->ch_layout, &p_sys->p_context->ch_layout);
+#else
         p_sys->frame->channel_layout = p_sys->p_context->channel_layout;
         p_sys->frame->channels = p_sys->p_context->channels;
+#endif
 
         const int in_bytes = p_sys->frame->nb_samples *
-            p_sys->p_context->channels * p_sys->i_sample_bytes;
+            p_enc->fmt_out.audio.i_channels* p_sys->i_sample_bytes;
 
         if( p_sys->b_planar )
         {
             aout_Deinterleave( p_sys->p_buffer, p_aout_buf->p_buffer,
-                               p_sys->frame->nb_samples, p_sys->p_context->channels, p_enc->fmt_in.i_codec );
+                               p_sys->frame->nb_samples, p_enc->fmt_out.audio.i_channels, p_enc->fmt_in.i_codec );
 
         }
         else
@@ -1431,7 +1467,7 @@ static block_t *EncodeAudio( encoder_t *p_enc, block_t
             memcpy(p_sys->p_buffer, p_aout_buf->p_buffer, in_bytes);
         }
 
-        if( avcodec_fill_audio_frame( p_sys->frame, p_sys->p_context->channels,
+        if( avcodec_fill_audio_frame( p_sys->frame, p_enc->fmt_out.audio.i_channels,
                                     p_sys->p_context->sample_fmt,
                                     p_sys->p_buffer,
                                     p_sys->i_buffer_out,
@@ -1457,7 +1493,7 @@ static block_t *EncodeAudio( encoder_t *p_enc, block_t
     if( p_aout_buf->i_nb_samples > 0 )
     {
        memcpy( p_sys->p_buffer + buffer_delay, p_aout_buf->p_buffer,
-               p_aout_buf->i_nb_samples * p_sys->i_sample_bytes * p_sys->p_context->channels);
+               p_aout_buf->i_nb_samples * p_sys->i_sample_bytes * p_enc->fmt_out.audio.i_channels);
        p_sys->i_samples_delay += p_aout_buf->i_nb_samples;
     }
 
@@ -1475,9 +1511,8 @@ void EndVideoEnc( vlc_object_t *p_this )
     av_frame_free( &p_sys->frame );
 
     vlc_avcodec_lock();
-    avcodec_close( p_sys->p_context );
-    vlc_avcodec_unlock();
     avcodec_free_context( &p_sys->p_context );
+    vlc_avcodec_unlock();
 
 
     av_free( p_sys->p_interleave_buf );
