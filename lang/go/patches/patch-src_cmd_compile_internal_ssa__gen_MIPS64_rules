Index: src/cmd/compile/internal/ssa/_gen/MIPS64.rules
--- src/cmd/compile/internal/ssa/_gen/MIPS64.rules.orig
+++ src/cmd/compile/internal/ssa/_gen/MIPS64.rules
@@ -306,12 +306,12 @@
 // 8, and 128 are magic constants, see runtime/mkduff.go
 (Zero [s] {t} ptr mem)
 	&& s%8 == 0 && s > 24 && s <= 8*128
-	&& t.Alignment()%8 == 0 =>
+	&& t.Alignment()%8 == 0 && !config.noDuffDevice =>
 	(DUFFZERO [8 * (128 - s/8)] ptr mem)
 
 // large or unaligned zeroing uses a loop
 (Zero [s] {t} ptr mem)
-	&& s > 8*128 || t.Alignment()%8 != 0 =>
+	&& (s > 8*128 || config.noDuffDevice) || t.Alignment()%8 != 0 =>
 	(LoweredZero [t.Alignment()]
 		ptr
 		(ADDVconst <ptr.Type> ptr [s-moveSize(t.Alignment(), config)])
@@ -382,7 +382,7 @@
 // medium move uses a duff device
 (Move [s] {t} dst src mem)
 	&& s%8 == 0 && s >= 24 && s <= 8*128 && t.Alignment()%8 == 0
-	&& logLargeCopy(v, s)  =>
+	&& !config.noDuffDevice && logLargeCopy(v, s)  =>
 	(DUFFCOPY [16 * (128 - s/8)] dst src mem)
 // 16 and 128 are magic constants.  16 is the number of bytes to encode:
 //	MOVV	(R1), R23
